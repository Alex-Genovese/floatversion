#!/bin/bash

# (c) Alex Genovese  https://github.com/TuxVinyards/floatversion
# License: MIT

# Extracts point separated numbers, or semantic version numbers with optional suffixes,
# and other common variations upon, from a given string or text list

# Script outputs as true/false test, as single item, or as space or line separated list. 
# If function (full or compact) is embedded, produces optional array '${fvOutputArr[*]}'

# Sorts to unique or listed entries, or to latest version in std numeric or sem. ver. 

# Uses'jq' for sorting suffixes, unless specified. 
# Neither are perfect but tests show jq method to be slightly better than sort -V 
# Also as various 'version-sort' algorithms may exist, sort -V may not be consistent.

# If embedding, this flag can be set (=1) as global by the calling script if needed ...
UseSortV=
UseSortVfallback=

# http://semver.org/ versioning does not list well in file managers.

# Use C.UTF-8  where possible as has more locale  See https://wiki.archlinux.org/title/Locale 
# NB if embedding, make sure that this or LC_ALL=C.UTF-8 or LC_ALL=C is present in the main script
if  grep -sqi 'C.utf8' <<< "$(locale -a)"; then export "LC_NUMERIC=C.UTF-8" ; export "LC_COLLATE=C.UTF-8"
else export "LC_NUMERIC=C" ; export "LC_COLLATE=C"
fi

if [ -z "$(command -v bash)" ] || [ "$(echo "$BASH_VERSION" | cut -d. -f1)" -lt 5 ]; then
  # posix compliant test
  echo; echo "  Sorry, you need Bash, probably 5.0 or newer to run this script."; echo
  echo "  FloatVersion has only been tested on up-to-date versions of Bash"; echo
  echo "  Certain elements require at least ver 4.2 .... "; echo
  if [ -n "$(command -v bash)" ]; then echo "  Your version: "; echo ; bash --version ; echo ; fi
fi

if [ -n "$UseSortV" ] &&  ! sort --help | grep -q -o 'version-sort' ; then 
  if [ -z "$UseSortVfallback" ]; then
      echo; echo "  Sorry, 'sort -V' is not available, you need 'jq' to run this script."; echo
  else UseSortV= ; fi
fi

if [ -z "$UseSortV" ] && [ -z "$(command -v jq)" ]; then
  echo; echo "  Sorry, you need to install 'jq' to run this script."; echo
fi

# flag for dev analysis, set =1 to show algorithm output (full version only)
Verbose=

# flag for dev analysis, set =1 to use compact version when running from script  OR --compact  as $1
CompactVersion=

##

float_version_from_string ()  {

	show_help () {
	  printf "
  floatversion --options  \"quoted-input-source\"

  Extracts point separated numbers, or semantic version numbers with optional suffixes,
  and other common variations upon, from a given string or text-file

  -h | --help         show help 
  -V | --version      show version
  -c | --col          show list as column instead of string (unless -M)
  -r | --rev          show list in reverse order  
  -a | --all          show all extracted values, not just unique 
  -n | --num          sort by standard numbering, not versioning
  -f | --full         check for additional sem. ver. suffixes,  eg. -beta
  -F | --filter       contains given items -F  \"string  string  string\" 
  -S | --starts       starting with -S  \"string  string  string\" 
  -D | --delete       doesn't contain: -D  \"string  string  string\" 
  -M | --max          outputs the highest/latest value in list, only, with '-r' shows lowest/earliest
  -g | --gt           if A is greater than B, returns true, else false (from string of two floats,'-r' is ignored)
  -v | --verbose      for problem output, show algorithm sequences (full version only) 

  Without options, produces a single sorted string of all unique items found
  Filters output as string, column or max. Post-output grep requires columns.
  All cases, returns false if none
  
  License: MIT  Copyright (c) Alex Genovese  
  Further Usage/Help/Details @ https://github.com/TuxVinyards/floatversion

"
  }

  local ShowAsCol=
  local ShowAsStr=
  local ShowMax=
  local ShowAll=
  local ShowRev=
  local SortNum=
  local GrepFull=
  local InputText=
  local Nums=
  local NumsCount=
  local FilterString=
  local StartString=
  local DeleteString=   
  local GTcompare=
  [[ ! $Verbose ]] && local Verbose=
  declare -a NumArrTemp 
  declare -a NumArrSorted 
  declare -a FilterArr 
  declare -a StartArr 
  declare -a DeleteArr 
  declare -a SelectArrTemp
  declare -ga fvOutputArr  
  
  while [[ "$1" ]] ; do
    case "$1" in 
      -h|--help)  
        show_help ; return 0 ;;
      -V|--version)  
        echo "1.0.0" ; return 0 ;;
      -c|--col)
        ShowAsCol=1 ; shift ;;
      -r|--rev)
        ShowRev=1 ; shift ;;
      -a|--all)
        ShowAll=1 ; shift ;;
      -n|--num)
        SortNum=1 ; shift ;;
      -f|--full)
        GrepFull=1 ; shift ;;
      -F|--filter)
        [[ ! $2 ]] && show_help && return 1
        FilterString="$2" ; shift 2 ;;
      -S|--start)
        [[ ! $2 ]] && show_help && return 1
        StartString="$2" ; shift 2 ;;
      -D|--delete)
        [[ ! $2 ]] && show_help && return 1
        DeleteString="$2" ; shift 2 ;;
      -M|--max)
        ShowMax=1 ; shift ;;
      -g|--gt)
        GTcompare=1; shift ;;
      -v|--verbose)
        Verbose=1 ; shift ;;
      *) 
        if [[ "$1" == '-'* ]]; then
          printf "\n\n  ERROR:  '%s'  not recognised \n\n"  "$1"
          show_help ; return 1
        elif [[ $InputText ]]; then
          printf "\n\n  ERROR: QUOTED Input String or Text File Name should be given only once \n\n" 
          show_help ; return 1
        else
          InputText="$1" ; shift 
        fi ;;
    esac
  done

  # sanitize and make sure that input is a safe line separated list, or becomes one
  [[ -e "$InputText" ]] && InputText="$(cat -A "$InputText")"
  InputText="$(tr -cd '[:print:]' <<< "$InputText" | tr ';' ' ' | tr '$' ' \n' | tr ' ' '\n' | grep -E '[[:print:]]')" 

  if [[ ! $InputText ]]; then 
    printf "\n\n  ERROR: no input found.  Is input present as a quoted element? \n\n"  
    show_help ; return 1
  fi

  [[ $FilterString ]] && mapfile -t FilterArr <<< "$(tr ' ' '\n' <<< "$FilterString")"
  [[ $StartString ]] && mapfile -t StartArr <<< "$(tr ' ' '\n' <<< "$StartString")"
  [[ $DeleteString ]] && mapfile -t DeleteArr <<< "$(tr ' ' '\n' <<< "$DeleteString")"

  if [[ $ShowMax ]]; then ShowAsStr= ; ShowAsCol=
  elif [[ $ShowAsCol ]]; then ShowAsStr=
  else ShowAsStr=1
  fi

  if [[ $Verbose ]]; then 
    echo; echo "Str: ($(wc -l <<< "$InputText"))"; echo "$InputText"; echo 
    printf "Filters: -F \"%s\" -S \"%s\"  -D \"%s\" \n\n"  "$FilterString" "$StartString"  "$DeleteString" 
    declare -p FilterArr ; echo
    declare -p StartArr ; echo
    declare -p DeleteArr ; echo
  fi

  # extract 
  if [[ $GrepFull ]]; then 
    Nums="$(grep -Eo \
    '[0-9]+([.][0-9]+)+([.][0-9]+)?+([.][0-9]+)?+([.][0-9]+)?+([-][[:alnum:]]+)?+([.][[:digit:]]+)?' <<< \
    "$InputText" )"
    printf -v Nums "%s\n" "$Nums"
  else
   # grep for all entries but then remove any with suffixes 
   Nums="$(grep -Eo \
   '[0-9]+([.][0-9]+)+([.][0-9]+)?+([.][0-9]+)?+([.][0-9]+)?+([-][[:alnum:]]+)?+([.][[:digit:]]+)?' <<< \
   "$InputText" | grep -v -E '[[:alpha:]]' )"
   printf -v Nums "%s\n" "$Nums"
  fi

  # check
  Nums="$(grep '[[:print:]]' <<< "$Nums")"
  NumsCount="$(wc -l <<< "$Nums")"

  [[ $Verbose ]] && { echo "Nums: ($NumsCount)"; echo "$Nums"; echo ;}

  if [[ $GTcompare ]] && [[ "$NumsCount" != 2 ]]; then 
    printf "\n\n  ERROR:  two floating point or semantic version values should be supplied \n\n"  
    show_help ; return 1
  fi

  # none found, return false
  [[ ! $Nums ]] && return 1

  mapfile -t NumArrTemp  <<< "$(tr ' ' '\n' <<< "$Nums")"
  [[ $Verbose ]] && { declare -p NumArrTemp ; echo ;}

  # sort unique, as required
  if [[ $ShowAll ]]; then  mapfile -t  NumArrSorted <<< "$(printf "%s\n" "${NumArrTemp[@]}" | sort )"
  else mapfile -t  NumArrSorted <<< "$(printf "%s\n" "${NumArrTemp[@]}" | sort -u )"
  fi

  [[ $Verbose ]] && { declare -p NumArrSorted ; echo ;}
  [[ $Verbose ]] && [[ $UseSortV ]] && { echo "Using SortV" ; echo ;}
  
  # sort into order
  if [[ $SortNum ]]; then
    mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrSorted[@]}" | sort -n )"
  elif [[ $UseSortV ]]; then
    mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrSorted[@]}" | sort -V )"
  else
    mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrSorted[@]}" | jq -Rrn '
      # https://stackoverflow.com/a/77961624/27611101
      # read input lines as an array
      [inputs]
      |sort_by( 
        # ignore build
        split("+")[0]
        # extract version core and pre-release as arrays of numbers and strings
        |split("-")|(.[0]|split(".")|map(tonumber? // .)) as $version_core
        |(.[1:]|join("-")|split(".")|map(tonumber? // .)) as $pre_release
        # sort by
        |$version_core,
        # pre-release versions have a lower precedence than the associated normal version
        ($pre_release|length)==0,
        # sort by 
        $pre_release
      )
      #extract values from an array
      |.[]'
    )"
  fi    

  [[ $Verbose ]] && { declare -p fvOutputArr ; echo; }

  # Filters
  if [[ ! $GTcompare ]]; then 
    if [[ $FilterString ]]; then n=0
      while [[ $n -lt "${#FilterArr[@]}" ]]; do
        [[ $Verbose ]] && { echo "Select: ${FilterArr[n]}"; echo ;}
        NumArrTemp=(); i=0 
        mapfile -t  NumArrTemp <<< "$(printf "%s\n" "${fvOutputArr[@]}" | grep "${FilterArr[n]}")"
        [[ $Verbose ]] && { declare -p NumArrTemp ; echo ;}
        while [[ $i -lt "${#NumArrTemp[@]}" ]]; do SelectArrTemp+=("${NumArrTemp[i]}"); ((i+=1)); done
        [[ $Verbose ]] && { declare -p SelectArrTemp ; echo ;}
        ((n++))
      done 
      fvOutputArr=(); i=0 
      while [[ $i -lt "${#SelectArrTemp[@]}" ]]; do fvOutputArr+=("${SelectArrTemp[i]}"); ((i+=1)); done
      [[ $Verbose ]] && { declare -p fvOutputArr ; echo; }
    fi
    if [[ $StartString ]]; then n=0
      while [[ $n -lt "${#StartArr[@]}" ]]; do
        [[ $Verbose ]] && { echo "Starts: ${StartArr[n]}"; echo ;}
        NumArrTemp=(); i=0 
        mapfile -t  NumArrTemp <<< "$(printf "%s\n" "${fvOutputArr[@]}" | grep -E ^"${StartArr[n]}")"
        [[ $Verbose ]] && { declare -p NumArrTemp ; echo ;}
        while [[ $i -lt "${#NumArrTemp[@]}" ]]; do SelectArrTemp+=("${NumArrTemp[i]}"); ((i+=1)); done
        [[ $Verbose ]] && { declare -p SelectArrTemp ; echo ;}
        ((n++))
      done 
      fvOutputArr=(); i=0 
      while [[ $i -lt "${#SelectArrTemp[@]}" ]]; do fvOutputArr+=("${SelectArrTemp[i]}"); ((i+=1)); done
      [[ $Verbose ]] && { declare -p fvOutputArr ; echo; }
    fi
    if [[ $DeleteString ]]; then n=0
      while [[ $n -lt "${#DeleteArr[@]}" ]]; do
         [[ $Verbose ]] && { echo "Delete: ${DeleteArr[n]}"; echo ;}
        NumArrTemp=(); i=0 
        while [[ $i -lt "${#fvOutputArr[@]}" ]]; do NumArrTemp+=("${fvOutputArr[i]}"); ((i+=1)); done
        [[ $Verbose ]] && { declare -p NumArrTemp ; echo ;}
        mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrTemp[@]}" | grep -v "${DeleteArr[n]}")"
        [[ $Verbose ]] && { declare -p fvOutputArr ; echo; }
        ((n++))
      done
    fi
    if [[ $ShowRev ]]; then 
      NumArrTemp=(); i="${#fvOutputArr[@]}"; ((i-=1))
      while [[ $i -ge 0  ]]; do NumArrTemp+=("${fvOutputArr[i]}"); ((i-=1)); done
      [[ $Verbose ]] && { declare -p NumArrTemp ; echo ;}
      mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrTemp[@]}")"
      [[ $Verbose ]] && { declare -p fvOutputArr ; echo; }
    fi
  fi

  # output
  if [[ $GTcompare ]]; then
    if [[ "${NumArrTemp[0]}" == "${fvOutputArr[-1]}" ]] && [[ "${NumArrTemp[0]}" != "${NumArrTemp[1]}" ]]; then 
    [[ $Verbose ]] && { echo "true"; echo ;} ; return 0
    else [[ $Verbose ]] && { echo "false"; echo ;} ; return 1
    fi
  elif [[ $ShowAsStr || $ShowAll ]] && [[ ! $ShowAsCol ]]; then
    printf "%s  " "${fvOutputArr[@]}"
    printf "\n"
  elif [[ $ShowAsCol ]]; then
    printf "%s\n" "${fvOutputArr[@]}"
  else
    echo "${fvOutputArr[-1]}"
  fi

}

##

# COMPACT VERSION, suitable for embedding into other scripts, if preferred  (help and annotation removed)
# # NB make sure that locale is set in the main script. See notes at start.

float_version ()  {
  # floatversion --options  "quoted-input-string-or-text-file" 
  # (c) Alex Genovese - version 1.0.0 (compact) - Usage/Help/Details @ https://github.com/TuxVinyards/floatversion
  local ShowAsStr= ; local ShowAsCol= ; local ShowMax= ; local ShowRev= ; local ShowAll= ; local SortNum= ; local GrepFull= 
  local InputText= ; local Nums= ; local NumsCount= ; local FilterString= ; local StartString= ; local DeleteString= ; local GTcompare=
  declare -a NumArrTemp ; declare -a NumArrSorted ; declare -a FilterArr ; declare -a StartArr ; declare -a DeleteArr
  declare -a SelectArrTemp ; declare -ga fvOutputArr  
  while [[ "$1" ]] ; do
    case "$1" in 
      -c|--col)     ShowAsCol=1 ; shift ;;
      -r|--rev)     ShowRev=1 ; shift ;;
      -a|--all)     ShowAll=1 ; shift ;;
      -n|--num)     SortNum=1 ; shift ;;
      -f|--full)    GrepFull=1 ; shift ;;
      -F|--filter)  [[ ! $2 ]] && show_help && return 1 ; FilterString="$2" ; shift 2 ;;
      -S|--start)   [[ ! $2 ]] && show_help && return 1 ; StartString="$2" ; shift 2 ;;
      -D|--delete)  [[ ! $2 ]] && show_help && return 1 ; DeleteString="$2" ; shift 2 ;;
      -M|--max)     ShowMax=1 ; shift ;;
      -g|--gt)      GTcompare=1 ; shift ;;
      *)  if [[ "$1" == '-'* ]]; then printf "\n\n  ERROR:  '%s'  not recognised \n\n"  "$1"; show_help ; return 1
          elif [[ $InputText ]]; then printf "\n\n  ERROR:  QUOTED Input String or Text File Name should be given only once \n\n" ; show_help ; return 1
          else InputText="$1" ; shift ; fi ;;
    esac
  done
  [[ -e "$InputText" ]] && InputText="$(cat -A "$InputText")"
  InputText="$(tr -cd '[:print:]' <<< "$InputText" | tr ';' ' ' | tr '$' ' ' | tr ' ' '\n' | grep -E '[[:print:]]')" 
  [[ ! $InputText ]] && printf "\n\n  ERROR: no input found.  Is '-i' or '-g' the last parameter plus input the last quoted element? \n\n" && return 1
  [[ $FilterString ]] && mapfile -t FilterArr <<< "$(tr ' ' '\n' <<< "$FilterString")"
  [[ $StartString ]] && mapfile -t StartArr <<< "$(tr ' ' '\n' <<< "$StartString")"
  [[ $DeleteString ]] && mapfile -t DeleteArr <<< "$(tr ' ' '\n' <<< "$DeleteString")" 
  if [[ $ShowMax ]]; then ShowAsStr= ; ShowAsCol= ; elif [[ $ShowAsCol ]]; then ShowAsStr= ; else ShowAsStr=1 ; fi
  if [[ $GrepFull ]]; then Nums="$(grep -Eo '[0-9]+([.][0-9]+)+([.][0-9]+)?+([.][0-9]+)?+([.][0-9]+)?+([-][[:alnum:]]+)?+([.][[:digit:]]+)?' <<< "$InputText" )"
  else Nums="$(grep -Eo '[0-9]+([.][0-9]+)+([.][0-9]+)?+([.][0-9]+)?+([.][0-9]+)?' <<< "$InputText" )"; fi ;  printf -v Nums "%s\n" "$Nums"
  Nums="$(grep '[[:print:]]' <<< "$Nums")" ; NumsCount="$(wc -l <<< "$Nums")" 
  [[ $GTcompare ]] && [[ "$NumsCount" != 2 ]] && printf "\n\n  ERROR:  two floating point or semantic version values should be supplied \n\n" && return 1
  [[ ! $Nums ]] && return 1
  mapfile -t NumArrTemp  <<< "$(tr ' ' '\n' <<< "$Nums")"
  if [[ $ShowAll ]]; then mapfile -t  NumArrSorted <<< "$(printf "%s\n" "${NumArrTemp[@]}" | sort )"
  else mapfile -t  NumArrSorted <<< "$(printf "%s\n" "${NumArrTemp[@]}" | sort -u )" ; fi
  if [[ $SortNum ]]; then mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrSorted[@]}" | sort -n )"
  else
    mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrSorted[@]}" | jq -Rrn '
    [inputs] |sort_by( split("+")[0]
      |split("-")|(.[0]|split(".")|map(tonumber? // .)) as $version_core
      |(.[1:]|join("-")|split(".")|map(tonumber? // .)) as $pre_release
      |$version_core, ($pre_release|length)==0, $pre_release
    ) |.[]' )"
  fi  
  if [[ ! $GTcompare ]]; then 
    if [[ $FilterString ]]; then n=0
      while [[ $n -lt "${#FilterArr[@]}" ]]; do NumArrTemp=(); i=0 
        mapfile -t  NumArrTemp <<< "$(printf "%s\n" "${fvOutputArr[@]}" | grep "${FilterArr[n]}")"
        while [[ $i -lt "${#NumArrTemp[@]}" ]]; do SelectArrTemp+=("${NumArrTemp[i]}"); ((i+=1)); done; ((n++))
      done 
      fvOutputArr=(); i=0 ; while [[ $i -lt "${#SelectArrTemp[@]}" ]]; do fvOutputArr+=("${SelectArrTemp[i]}"); ((i+=1)); done
    fi
    if [[ $StartString ]]; then n=0
      while [[ $n -lt "${#StartArr[@]}" ]]; do NumArrTemp=(); i=0 
        mapfile -t  NumArrTemp <<< "$(printf "%s\n" "${fvOutputArr[@]}" | grep -E ^"${StartArr[n]}")"
        while [[ $i -lt "${#NumArrTemp[@]}" ]]; do SelectArrTemp+=("${NumArrTemp[i]}"); ((i+=1)); done; ((n++))
      done 
      fvOutputArr=(); i=0 ; while [[ $i -lt "${#SelectArrTemp[@]}" ]]; do fvOutputArr+=("${SelectArrTemp[i]}"); ((i+=1)); done
    fi
    if [[ $DeleteString ]]; then n=0
      while [[ $n -lt "${#DeleteArr[@]}" ]]; do NumArrTemp=(); i=0 
        while [[ $i -lt "${#fvOutputArr[@]}" ]]; do NumArrTemp+=("${fvOutputArr[i]}"); ((i+=1)); done
        mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrTemp[@]}" | grep -v "${DeleteArr[n]}")" ; ((n++))
      done
    fi
    if [[ $ShowRev ]]; then NumArrTemp=(); i="${#fvOutputArr[@]}"; ((i-=1))
      while [[ $i -ge 0  ]]; do NumArrTemp+=("${fvOutputArr[i]}"); ((i-=1)); done
      mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrTemp[@]}")"
    fi
  fi
  if [[ $GTcompare ]]; then 
    if [[ "${NumArrTemp[0]}" == "${fvOutputArr[-1]}" ]] && [[ "${NumArrTemp[0]}" != "${NumArrTemp[1]}" ]]; then return 0 ; else return 1 ; fi
  elif [[ $ShowAsStr || $ShowAll ]] && [[ ! $ShowAsCol ]]; then printf "%s  " "${fvOutputArr[@]}" ; printf "\n"
  elif [[ $ShowAsCol ]]; then printf "%s\n" "${fvOutputArr[@]}"
  else  echo "${fvOutputArr[-1]}"
  fi
}


##

# script call, developer option
if [[ $1 == "--compact" ]]; then shift ; float_version "$@"
elif [[ $CompactVersion ]]; then  float_version "$@"
else float_version_from_string "$@"
fi

# https://code.visualstudio.com/ 
# vim:tabstop=2:shiftwidth=2:expandtab
