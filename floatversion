#!/bin/bash

# (c) Alex Genovese  https://github.com/TuxVinyards/floatversion
# License: MIT

# Extracts point separated numbers, or semantic version numbers with optional suffixes,
# and other common variations upon, from a given string or text list

# Script outputs as true/false test, as single item, or as space or line separated list. 
# If function (full or compact) is embedded, produces optional array '${fvOutputArr[*]}'

# Sorts to unique or listed entries, or to latest version in std numeric or sem. ver. 

# Uses'jq' for version sorting as only Gnu sort has 'sort -V'  
# and this is noticably absent both in Debian based distros and with MacOS
# jq code source - https://stackoverflow.com/a/77961624/27611101

# http://semver.org/ versioning does not list well in file managers.

if [ -z "$(command -v bash)" ] || [ "$(echo "$BASH_VERSION" | cut -d. -f1)" -lt 5 ]; then
  # posix compliant test
  echo; echo "  Sorry, you need Bash, probably 5.0 or newer to run this script."; echo
  echo "  FloatVersion has only been tested on up-to-date versions of Bash"; echo
  echo "  Certain elements require at least ver 4.2 .... "; echo
  if [ -n "$(command -v bash)" ]; then echo "  Your version: "; echo ; bash --version ; echo
  fi
fi

if [ -z "$(command -v jq)" ]; then
  echo; echo "  Sorry, you need to install 'jq' to run this script."; echo
fi

# flag for dev analysis, set =1 to show algorithm output (full version only)
Verbose=

# flag for dev analysis, set =1 to use compact version
CompactVersion=

##

float_version_from_string ()  {

	show_help () {
	  printf "
  floatversion --options  --input | --gt  \"QUOTED-string\"

  Extracts point separated numbers, or semantic version numbers with optional suffixes,
  and other common variations upon, from a given string or text list

  -h | --help         show help 
  -V | --version      show version
  -s | --str          show list as single string
  -c | --col          show list as column
  -r | --rev          show list in reverse order  
  -a | --all          show all extracted values, not just unique 
  -n | --num          sort by standard numbering, not versioning
  -f | --full         check for additional sem. ver. suffixes,  eg. -beta
  -F | --filter       allows filtered output in single string, whereas post output grep requires columns,
  -S | --starts       with -F as contains and -S as starting with, and -I as doesn't contain
  -I | --inverse      all 3 may be used together, if required,  -F | -S | -I 'quoted-string'
  -i | --input        input string, text or list (for comparisons, use -g instead)
  -g | --gt           if A is greater than B, returns true, else false (from string of two, '-r' is ignored)
  -v | --verbose      for problem output, show algorithm sequences (full version only) 

  Without options, outputs the highest/latest value in list, with '-r' shows lowest/earliest
  All cases, returns false if none
  
  License: MIT  Copyright (c) Alex Genovese  
  Further Usage/Help/Details @ https://github.com/TuxVinyards/floatversion

"
  }

  local ShowAsCol=
  local ShowAsStr=
  local ShowAll=
  local ShowRev=
  local SortNum=
  local GrepFull=
  local InputString=
  local FilterString=
  local StartString=
  local InverseString=
  local GTcompare=
  [[ ! $Verbose ]] && local Verbose=
  declare -a NumArrTemp 
  declare -a NumArrSorted 
  declare -ga fvOutputArr  
  
  while [[ "$1" ]] ; do
    case "$1" in 
      --help|-h)  
        show_help ; return 0 ;;
      -V|--version)  
        echo "1.0.0" ; return 0 ;;
      -s|--str)
        ShowAsStr=1 ; shift ;;
      -c|--col)
        ShowAsCol=1 ; shift ;;
      -r|--rev)
        ShowRev=1 ; shift ;;
      -a|--all)
        ShowAll=1 ; shift ;;
      -n|--num)
        SortNum=1 ; shift ;;
      -f|--full)
        GrepFull=1 ; shift ;;
      -F|--filter)
        [[ ! $2 ]] && show_help && return 1
        FilterString="$2" ; shift $# ;;
      -S|--start)
        [[ ! $2 ]] && show_help && return 1
        StartString="$2" ; shift $# ;;
      -I|--inverse)
        [[ ! $2 ]] && show_help && return 1
        InverseString="$2" ; shift $# ;;
      -i|--input)
        [[ ! $2 ]] && show_help && return 1
        InputString="$2" ; shift $# ;;
      -g|--gt)
        [[ ! $2 ]] && show_help && return 1
        GTcompare=1
        InputString="$2" ; shift $# ;;
      -v|--verbose)
        Verbose=1 ; shift ;;
      *) 
        printf "\n\n  ERROR:  '%s'  not recognised \n\n"  "$1"
        show_help ; return 1 ;;
    esac
  done

  # sanitize
  [[ -e "$InputString" ]] && InputString="$(cat -A "$InputString")"
  InputString="$(tr -cd '[:print:]' <<< "$InputString" | tr ';' ' ' | tr '$' ' \n')" 

  if [[ ! $InputString ]]; then 
    printf "\n\n  ERROR: no input found.  Is '-i' or '-g' the last parameter plus input the last quoted element? \n\n"  
    show_help ; return 1
  fi

  [[ $Verbose ]] && { echo; echo "Str:"; echo "$InputString"; echo ;}

  if [[ $GrepFull ]]; then 
    Nums="$(grep -Eo \
    '[0-9]+([.][0-9]+)+([.][0-9]+)?+([.][0-9]+)?+([.][0-9]+)?+([-][[:alnum:]]+)?+([.][[:digit:]]+)?' <<< \
    "$InputString" )"
    printf -v Nums "%s\n" "$Nums"
  else
   # grep for all entries but then remove any with suffixes 
   Nums="$(grep -Eo \
   '[0-9]+([.][0-9]+)+([.][0-9]+)?+([.][0-9]+)?+([.][0-9]+)?+([-][[:alnum:]]+)?+([.][[:digit:]]+)?' <<< \
   "$InputString" | grep -v -E '[[:alpha:]]' )"
   printf -v Nums "%s\n" "$Nums"
  fi

  # further sanitize
  Nums="$(grep '[[:digit:]]' <<< "$Nums")"
  [[ $Verbose ]] && { echo "Nums: ($(grep -c '[[:digit:]]' <<< "$Nums"))"; echo "$Nums"; echo ;}
  
  # none found, return false
  [[ ! $Nums ]] && return 1

  mapfile -t NumArrTemp  <<< "$(tr ' ' '\n' <<< "$Nums")"

  if [[ $GTcompare ]] && [[ "${#NumArrTemp[@]}" -gt 2 ]]; then 
    printf "\n\n  ERROR:  only two values should be supplied \n\n"  
    show_help ; return 1
  fi

  [[ $Verbose ]] && { declare -p NumArrTemp ; echo ;}

  if [[ $ShowAll ]]; then 
    mapfile -t  NumArrSorted <<< "$(printf "%s\n" "${NumArrTemp[@]}" | sort )"
  else
    mapfile -t  NumArrSorted <<< "$(printf "%s\n" "${NumArrTemp[@]}" | sort -u )"
  fi

  [[ $Verbose ]] && { declare -p NumArrSorted ; echo ;}
  
  if [[ $SortNum ]]; then
    mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrSorted[@]}")"
  else
    mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrSorted[@]}" | jq -Rrn '
    # read input lines as an array
    [inputs]
    |sort_by(
      # ignore build
      split("+")[0]
      # extract version core and pre-release as arrays of numbers and strings
      |split("-")|(.[0]|split(".")|map(tonumber? // .)) as $version_core
      |(.[1:]|join("-")|split(".")|map(tonumber? // .)) as $pre_release
      # sort by
      |$version_core,
      # pre-release versions have a lower precedence than the associated normal version
      ($pre_release|length)==0,
      # sort by 
      $pre_release
    )
    #extract values from an array
    |.[]'
    )"
  fi    

  [[ $Verbose ]] && { declare -p fvOutputArr ; echo; }

  # Filters
  if [[ ! $GTcompare ]]; then 
    if [[ $ShowRev ]] && ; then 
      NumArrTemp=(); i="${#fvOutputArr[@]}"; ((i-=1))
      while [[ $i -ge 0  ]]; do NumArrTemp+=("${fvOutputArr[i]}"); ((i-=1)); done
      [[ $Verbose ]] && { declare -p NumArrTemp ; echo ;}
      mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrTemp[@]}")"
      [[ $Verbose ]] && { declare -p fvOutputArr ; echo; }
    fi
    if [[ $FilterString ]] && ; then 
      NumArrTemp=(); i="${#fvOutputArr[@]}"; ((i-=1))
      while [[ $i -ge 0  ]]; do NumArrTemp+=("${fvOutputArr[i]}"); ((i-=1)); done
      [[ $Verbose ]] && { declare -p NumArrTemp ; echo ;}
      mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrTemp[@]}" | grep "$FilterString")"
      [[ $Verbose ]] && { declare -p fvOutputArr ; echo; }
    fi
    if [[ $StartString ]] && ; then 
      NumArrTemp=(); i="${#fvOutputArr[@]}"; ((i-=1))
      while [[ $i -ge 0  ]]; do NumArrTemp+=("${fvOutputArr[i]}"); ((i-=1)); done
      [[ $Verbose ]] && { declare -p NumArrTemp ; echo ;}
      mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrTemp[@]}" | grep -E ^"$StartString")"
      [[ $Verbose ]] && { declare -p fvOutputArr ; echo; }
    fi
    if [[ $InverseString ]] && ; then 
      NumArrTemp=(); i="${#fvOutputArr[@]}"; ((i-=1))
      while [[ $i -ge 0  ]]; do NumArrTemp+=("${fvOutputArr[i]}"); ((i-=1)); done
      [[ $Verbose ]] && { declare -p NumArrTemp ; echo ;}
      mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrTemp[@]}" | grep -v "$InverseString")"
      [[ $Verbose ]] && { declare -p fvOutputArr ; echo; }
    fi
  fi

  if [[ $ShowAsStr || $ShowAll ]] && [[ ! $ShowAsCol ]]; then
    printf "%s  " "${fvOutputArr[@]}"
    printf "\n"
  elif [[ $ShowAsCol ]]; then
    printf "%s\n" "${fvOutputArr[@]}"
  elif [[ $GTcompare ]]; then
    if [[ "${NumArrTemp[0]}" == "${fvOutputArr[-1]}" ]] && [[ "${NumArrTemp[0]}" != "${NumArrTemp[1]}" ]]; then 
    [[ $Verbose ]] && { echo "true"; echo ;} ; return 0
    else [[ $Verbose ]] && { echo "false"; echo ;} ; return 1
    fi
  else
    echo "${fvOutputArr[-1]}"
  fi

}

##

# compact version, suitable for embedding into other scripts, if preferred  (help and annotation removed)

float_version ()  {
  # floatversion --options  --input | --gt  "quoted-string"  
  # (c) Alex Genovese - version 1.0.0 (compact) - Usage/Help/Details @ https://github.com/TuxVinyards/floatversion
  local ShowAsStr= ; local ShowAsCol= ; local ShowRev= ; local ShowAll= ; local SortNum= ; local GrepFull=  
  local InputString= ; local GTcompare= ; declare -a NumArrTemp  ; declare -a NumArrSorted ; declare -ga fvOutputArr  
  while [[ "$1" ]] ; do
    case "$1" in 
      -s|--str)     ShowAsStr=1 ; shift ;;
      -c|--col)     ShowAsCol=1 ; shift ;;
      -r|--rev)     ShowRev=1 ; shift ;;
      -a|--all)     ShowAll=1 ; shift ;;
      -n|--num)     SortNum=1 ; shift ;;
      -f|--full)    GrepFull=1 ; shift ;;
      -i|--input)   [[ ! $2 ]] && return 1 ; InputString="$2" ; shift $# ;;
      -g|--gt) [[ ! $2 ]] && return 1 ; GTcompare=1 ; InputString="$2" ; shift $# ;;
      *) printf "\n\n  ERROR:  '%s'  not recognised \n\n"  "$1" ; return 1 ;;
    esac
  done
  [[ -e "$InputString" ]] && InputString="$(cat -A "$InputString")"
  InputString="$(tr -cd '[:print:]' <<< "$InputString" | tr ';' ' ' | tr '$' ' ')" 
  [[ ! $InputString ]] && printf "\n\n  ERROR: no input found.  Is '-i' or '-g' the last parameter plus input the last quoted element? \n\n" && return 1
  if [[ $GrepFull ]]; then Nums="$(grep -Eo '[0-9]+([.][0-9]+)+([.][0-9]+)?+([.][0-9]+)?+([.][0-9]+)?+([-][[:alnum:]]+)?+([.][[:digit:]]+)?' <<< "$InputString" )"
  else Nums="$(grep -Eo '[0-9]+([.][0-9]+)+([.][0-9]+)?+([.][0-9]+)?+([.][0-9]+)?' <<< "$InputString" )"; fi ;  printf -v Nums "%s\n" "$Nums"
  Nums="$(grep '[[:digit:]]' <<< "$Nums")" ; [[ ! $Nums ]] && return 1
  mapfile -t NumArrTemp  <<< "$(tr ' ' '\n' <<< "$Nums")"
  [[ $GTcompare ]] && [[ "${#NumArrTemp[@]}" -gt 2 ]] && printf "\n\n  ERROR:  only two values should be supplied \n\n"  && return 1
  if [[ $ShowAll ]]; then mapfile -t  NumArrSorted <<< "$(printf "%s\n" "${NumArrTemp[@]}" | sort )"
  else mapfile -t  NumArrSorted <<< "$(printf "%s\n" "${NumArrTemp[@]}" | sort -u )" ; fi
  if [[ $SortNum ]]; then mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrSorted[@]}")"
  else
    mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrSorted[@]}" | jq -Rrn '
    [inputs] |sort_by( split("+")[0]
      |split("-")|(.[0]|split(".")|map(tonumber? // .)) as $version_core
      |(.[1:]|join("-")|split(".")|map(tonumber? // .)) as $pre_release
      |$version_core, ($pre_release|length)==0, $pre_release
    ) |.[]' )"
  fi  
  if [[ $ShowRev ]] && [[ ! $GTcompare ]]; then 
    NumArrTemp=(); i="${#fvOutputArr[@]}"; ((i-=1))
    while [[ $i -ge 0  ]]; do NumArrTemp+=("${fvOutputArr[i]}"); ((i-=1)); done
    mapfile -t  fvOutputArr <<< "$(printf "%s\n" "${NumArrTemp[@]}")"
  fi
  if [[ $ShowAsStr || $ShowAll ]] && [[ ! $ShowAsCol ]]; then printf "%s  " "${fvOutputArr[@]}" ; printf "\n"
  elif [[ $ShowAsCol ]]; then printf "%s\n" "${fvOutputArr[@]}"
  elif [[ $GTcompare ]]; then 
    if [[ "${NumArrTemp[0]}" == "${fvOutputArr[-1]}" ]] && [[ "${NumArrTemp[0]}" != "${NumArrTemp[1]}" ]]; then return 0 
    else return 1 ; fi
  else  echo "${fvOutputArr[-1]}"
  fi
}


##

if [[ $CompactVersion ]]; then  float_version "$@"
else
  float_version_from_string "$@"
fi

# https://code.visualstudio.com/ 
# vim:tabstop=2:shiftwidth=2:expandtab
